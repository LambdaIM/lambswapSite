{"version":3,"sources":["webpack:///./src/contacthelp/ethcom.js","webpack:///./src/contacthelp/ethusdt.js","webpack:///./src/contactLogic/history.js","webpack:///./src/contactLogic/readpairpool.js"],"names":["Web3","require","getTime","web3","window","ethereum","chainConfig","walletconnectRPC","defaultChainID","Promise","resolve","reject","eth","getBlock","error","data","timestamp","getGasPrice","provider","toString","tokenNameByaddress","address","chainID","coinA","_","find","tokens","item","chainId","toLowerCase","undefined","symbol","swapExactTokensForTokensformat","inamount","amount","outamount","tokenADDRESSA","amount_token_address","tokenADDRESSB","tokenA","tokenB","BigNumber","Calculatepercentage","balance","totalSupply","balance_","totalSupply_","div","getTokenList","where","token","readpairpool","library","list","pairlist","pairList","PairList","dataList","forEach","element","route","Route","tokenAmounts","liquidityToken","target","one","pair","indexOf","price","pairs","priceOf","push","Pair","toSignificant","pairName","listSymbol","isfirst","pairSymbols","configSymbols","isHide","readpairpoolPrice","pairdataList","tokenList","PricePromiseList","coinB","TokenA","Token","decimals","TokenB","pairaddress","getAddress","getpairPrice","all","PriceList","prise24","change","prisechange","Math","abs","readpairLiquidity","account","callList","TokenContract","useTokenContractMulticall","balanceOf","ethcallProvider","Provider","init","listresult","index","totalSupplyTokenAmount","TokenAmount","balanceTokenAmount","utils","fromWei","aToketotalSupply","getLiquidityValue","bToketotalSupply","aTokenbalance","bTokenbalance","readpariInfo","tokensymbolA","tokensymbolB","Fetcher","fetchPairData","getethProvider","pairInfo","calculationLiquidity","coinATokenAmount","coinBTokenAmount","istargetBToken","invertprice","invert","outputNum","quote","pooltotalSupply","pooltotalSupplyTokenAmount","liquidityMinted","getLiquidityMinted","poolPercentData","divide","add","buildAddliquidityParam","ChainId","allowedSlippage","INITIAL_ALLOWED_SLIPPAGE","amountsMin","CURRENCY_A","calculateSlippageAmount","CURRENCY_B","blockTime","DEFAULT_DEADLINE_FROM_NOW","deadline","coinInfo","getChainCoinInfo","currency","coinName","isBisEth","args","raw","asciiToHex","checkoutTokenAllowance","TokenAContract","TokenBContract","allowance","ROUTER_ADDRESS","tokenAallowance","tokenBallowance","readpariInfoNuminfo","priceinvert","checkApprove","spender","Aallowance","Ballowance","tokenAnotNeed","tokenBnotNeed","aUserin","bUserin","lt","eq","addliquidityGas","parameters","ethamount","contract","getRouterContract","length","estimateGas","addLiquidityETH","value","estimatedGasLimit","addLiquidity","gasPrice","useWEI","mul","fee","sendaddliquidity","gasLimit","calculateGasMargin","result","pairPrice","PriceInfo","Data","txs","innum","outnum","toFixed","infoData","obj","pairAddress","UniswapV2Pair","useIUniswapV2PairABIContractMulticall","token0","token1","getReserves","tokrnAddressA","tokrnAddressB","reserve0","reserve1","sortsBefore","pairListEarn","pairListInfo","resultList","pledgebalance","pairprice"],"mappings":"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","file":"js/chunk-31d4f188.c5296199.js","sourcesContent":["const Web3 = require(\"web3\");\nimport chainConfig from '@/config/config.js';\n\n export async function getTime() {\n    const web3 = new Web3(window.ethereum||chainConfig.walletconnectRPC[chainConfig.defaultChainID]);\n    // const getBlock = util.promisify(web3.eth.getBlock)\n    return new Promise((resolve, reject) => {\n     web3.eth.getBlock(\"latest\", (error, data) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(data.timestamp);\n        }\n      });\n    });\n  }","// import gastoken  from  \"@/constants/gastoken.json\";\n\nimport { getNetwork } from '@ethersproject/networks';\nimport { getDefaultProvider } from '@ethersproject/providers';\n\nimport getethProvider from './getethProvider.js';\n\nimport {\n    ChainId,\n    Token,\n    Fetcher,\n    Route,\n    TokenAmount,\n    Router,\n  } from \"@webfans/uniswapsdk\";\n\n// export async function  ethusdt(){\n//     const USDT = gastoken.tokens[0];\n//     const WETH = gastoken.tokens[1];\n\n//     const USDTcoin = new Token(\n//         USDT.chainId,\n//         USDT.address,\n//         USDT.decimals,\n//         USDT.symbol\n//       );\n\n//     const WETHcoin = new Token(\n//         WETH.chainId,\n//         WETH.address,\n//         WETH.decimals,\n//         WETH.symbol\n//       );\n\n  \n  \n//     const pair = await Fetcher.fetchPairData(\n//         USDTcoin,\n//         WETHcoin,\n//         getethProvider(USDTcoin)\n//       );\n//       console.log(pair);\n//       const route = new Route([pair], WETHcoin);\n\n//       const price = route.pairs[0].priceOf(WETHcoin);\n//       console.log('eth to usdt',price.toSignificant(6)) ;\n//       return price.toSignificant(6);\n\n// }\n\nexport async function getGasPrice(provider){\n  const data = await provider.getGasPrice();\n  \n\n  \n  return data.toString();\n\n}","\nimport { swapHistory, buildrHistory, rewardMine } from \"@/constants/apiconfig.js\";\nimport _ from 'underscore';\nimport tokens from \"@/constants/token.json\";\n\nimport LPtoken from \"@/constants/minertoken.json\";\n\nexport async function readSwapHistory(chainID, account, pageNum, showNum) {\n  const data = await swapHistory(account, pageNum, showNum, chainID);\n  //['swapExactTokensForTokens','removeLiquidityWithPermit','addLiquidity']\n\n  data.data.forEach((item) => {\n    if (item.method_name == 'removeLiquidityWithPermit') {\n      item.show = removeLiquidityWithPermitformat(item.txs, chainID);\n    } else if (item.method_name == 'swapExactTokensForTokens') {\n      item.show = swapExactTokensForTokensformat(item.txs, chainID);\n    } else if (item.method_name == 'addLiquidity') {\n      item.show = addLiquidityformat(item.txs, chainID);\n\n    } else if (item.method_name == 'removeLiquidityETHWithPermit') {\n      item.show = removeLiquidityWithPermitformatETH(item.txs, chainID);\n\n    } else if (item.method_name == 'addLiquidityETH') {\n      item.show = addLiquidityformatETH(item.txs, chainID);\n\n    } else if (item.method_name == 'swapExactTokensForETH') {\n      item.show = swapExactTokensForTokensformatETH(item.txs, chainID);\n\n    } else if (item.method_name == 'removeLiquidityETHWithPermitSupportingFeeOnTransferTokens') {\n      item.show = removeLiquidityWithPermitformatETH(item.txs, chainID);\n\n    } else if (item.method_name == 'removeLiquidity') {\n      item.show = removeLiquidityWithformat(item.txs, chainID);\n\n    }\n\n    //removeLiquidityETHWithPermitSupportingFeeOnTransferTokens,\n\n\n  });\n\n\n\n  console.log(data);\n  return data;\n\n}\n\nexport async function readPledgeHistory(chainID, account, pageNum, showNum) {\n  const data = await rewardMine(account, pageNum, showNum);\n  //['stake','exit','getReward']\n\n  data.data.forEach((item) => {\n    if (item.method_name == 'stake') {\n      item.show = stakeformat(item.txs, chainID);\n    } else if (item.method_name == 'exit') {\n      item.show = exitformat(item.txs, chainID);\n    } else if (item.method_name == 'getReward') {\n      item.show = getRewardformat(item.txs, chainID);\n    } else if (item.method_name === 'leave') {\n      item.show = leaveFormat(item.txs, chainID);\n    }else if (item.method_name === 'enter') {\n      item.show = enterFormat(item.txs, chainID);\n    }\n  });\n  return data;\n\n}\n\nexport async function readbuildrHistory(chainID, account, pageNum, showNum) {\n  const data = await buildrHistory(account, pageNum, showNum, chainID);\n  //['stake','exit','getReward']\n\n  data.data.forEach((item) => {\n    item.show = proxyformat(item.txs, chainID);\n\n    // if(item.method_name == 'proxyMinted'){\n    //     item.show = proxyformat(item.txs,chainID);\n    // }else if( item.method_name == 'proxyBurned'){\n    //     // item.show = exitformat(item.txs,chainID);\n    // }else if(item.method_name == 'proxyJoined'){\n    //     // item.show = getRewardformat(item.txs,chainID);\n\n    // }else if(item.method_name == 'proxyExited'){\n    //     // item.show = getRewardformat(item.txs,chainID);\n\n    // }else if(item.method_name == 'approval'){\n    //     // item.show = getRewardformat(item.txs,chainID);\n\n    // }\n\n\n  });\n\n  return data;\n\n}\n\nfunction tokenNameByaddress(address, chainID) {\n  const coinA = _.find(tokens.tokens, (item) => {\n    if (item.chainId == chainID && item.address.toLowerCase() == address.toLowerCase()) {\n      return item;\n    }\n    // {chainId:chainID,address:address}\n  });\n  if (coinA == undefined) {\n    return '';\n  }\n  return coinA.symbol;\n\n}\n\nfunction tokenNameByaddressStack(address, chainID) {\n  const coinA = _.find(LPtoken.tokens, (item) => {\n    if (item.chainId == chainID && item.address.toLowerCase() == address.toLowerCase()) {\n      return item;\n    }\n    // {chainId:chainID,address:address}\n  });\n  if (coinA == undefined) {\n    return '';\n  }\n  return coinA.symbol;\n\n}\n\nfunction removeLiquidityWithPermitformat(item, chainID) {\n  const lpamount = item[0].amount;\n  const tokenADDRESSA = item[2].amount_token_address;\n  const tokenADDRESSB = item[3].amount_token_address;\n  const amountA = item[2].amount;\n  const amountB = item[3].amount;\n\n  return {\n    inamount: lpamount,\n    outamount: [amountA, amountB],\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n    tokenB: tokenNameByaddress(tokenADDRESSB, chainID)\n  };\n\n\n}\n\nfunction removeLiquidityWithPermitformatETH(item, chainID) {\n  const lpamount = item[0].amount;\n  const tokenADDRESSA = item[2].amount_token_address;\n  const tokenADDRESSB = item[3].amount_token_address;\n  const amountA = item[2].amount;\n  const amountB = item[3].amount;\n\n  return {\n    inamount: lpamount,\n    outamount: [amountA, amountB],\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n    tokenB: tokenNameByaddress(tokenADDRESSB, chainID)\n  };\n\n\n}\n\nfunction removeLiquidityWithformat(item, chainID) {\n  console.log('removeLiquidityWithformat');\n  const lpamount = item[0].amount;\n  const tokenADDRESSA = item[2].amount_token_address;\n  const tokenADDRESSB = item[3].amount_token_address;\n  const amountA = item[2].amount;\n  const amountB = item[3].amount;\n\n  return {\n    inamount: lpamount,\n    outamount: [amountA, amountB],\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n    tokenB: tokenNameByaddress(tokenADDRESSB, chainID)\n  };\n\n\n}\n\nexport function swapExactTokensForTokensformat(item, chainID) {\n  const inamount = item[0].amount;\n  const outamount = item[1].amount;\n\n  const tokenADDRESSA = item[0].amount_token_address;\n  const tokenADDRESSB = item[1].amount_token_address;\n\n  return {\n    inamount: inamount,\n    outamount: outamount,\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n    tokenB: tokenNameByaddress(tokenADDRESSB, chainID)\n  };\n\n}\n\nexport function swapExactTokensForTokensformatETH(item, chainID) {\n  const inamount = item[0].amount;\n  const outamount = item[1].amount;\n\n  const tokenADDRESSA = item[0].amount_token_address;\n  const tokenADDRESSB = item[1].amount_token_address;\n\n  return {\n    inamount: inamount,\n    outamount: outamount,\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n    tokenB: tokenNameByaddress(tokenADDRESSB, chainID)\n  };\n\n}\n\nfunction addLiquidityformat(item, chainID) {\n  const inamount = item[0].amount;\n  const outamount = item[1].amount;\n\n  const tokenADDRESSA = item[0].amount_token_address;\n  const tokenADDRESSB = item[1].amount_token_address;\n\n  const amountLP = item[2].amount;\n\n\n  return {\n    inamount: [inamount, outamount],\n    outamount: amountLP,\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n    tokenB: tokenNameByaddress(tokenADDRESSB, chainID)\n  };\n\n}\n\n\nfunction addLiquidityformatETH(item, chainID) {\n  const inamount = item[0].amount;\n  const outamount = item[1].amount;\n\n  const tokenADDRESSA = item[0].amount_token_address;\n  const tokenADDRESSB = item[1].amount_token_address;\n\n  const amountLP = item[2].amount;\n\n\n  return {\n    inamount: [inamount, outamount],\n    outamount: amountLP,\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n    tokenB: tokenNameByaddress(tokenADDRESSB, chainID)\n  };\n\n}\n\n\nfunction stakeformat(item, chainID) {\n  const inamount = item[0].amount;\n\n\n  const tokenADDRESSA = item[0].amount_token_address;\n  const poolADDRESS = item[0].to;\n\n  return {\n    inamount: inamount,\n    poolADDRESS,\n    tokenA: tokenNameByaddressStack(tokenADDRESSA, chainID),\n\n  };\n\n}\n\nfunction exitformat(item, chainID) {\n  const outamountA = item[0].amount;\n  const outamountB = item[1] ? item[1].amount : '';\n\n\n  const tokenADDRESSA = item[0].amount_token_address;\n  const tokenADDRESSB = item[1] ? item[1].amount_token_address : '';\n\n  const poolADDRESS = item[0].from;\n\n  return {\n    outamountA,\n    outamountB,\n    poolADDRESS,\n    tokenA: tokenNameByaddressStack(tokenADDRESSA, chainID),\n    tokenB: tokenNameByaddress(tokenADDRESSB, chainID)\n\n  };\n\n}\n\nfunction getRewardformat(item, chainID) {\n  const inamount = item[0].amount;\n\n\n  const tokenADDRESSA = item[0].amount_token_address;\n  const poolADDRESS = item[0].from;\n\n  return {\n    outamount: inamount,\n    poolADDRESS,\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n  };\n\n}\n\n\nfunction proxyBurnedformat(item, chainID) {\n  const inamount = item[0].amount;\n\n  const tokenADDRESSA = item[0].amount_token_address;\n\n  return {\n    amount: inamount,\n    tokenA: tokenNameByaddressStack(tokenADDRESSA, chainID),\n\n  };\n}\n\nfunction proxyformat(item, chainID) {\n  const inamount = item[0].amount;\n\n  const tokenADDRESSA = item[0].amount_token_address;\n\n  return {\n    amount: inamount,\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n\n  };\n}\n\nfunction leaveFormat(item, chainID) {\n  // 取出xmlamb\n  const outamountA =  item[0].amount;\n  // 取出lamb\n  const outamountB = item[1].amount;\n\n  const tokenADDRESSA = item[0].amount_token_address;\n  const tokenADDRESSB = item[1].amount_token_address;\n\n  const poolADDRESS = item[0].amount_token_address;\n  return {\n    outamountA,\n    outamountB,\n    poolADDRESS,\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n    tokenB: tokenNameByaddress(tokenADDRESSB, chainID)\n  };\n}\n\nfunction enterFormat(item, chainID) {\n  const outamountA = item[0].amount;\n  const tokenADDRESSA = item[0].amount_token_address;\n  const poolADDRESS = item[0].amount_token_address;\n  return {\n    outamountA,\n    poolADDRESS,\n    tokenA: tokenNameByaddress(tokenADDRESSA, chainID),\n  };\n}\n\n","import token from \"@/constants/token.json\";\nimport pairlist from \"@/constants/pairlist.json\";\n\nimport {\n  ChainId, Token, TokenAmount, Fetcher,\n  Route, Percent, Router,Pair\n} from \"@webfans/uniswapsdk\";\n\n// import { useTokenbalance } from \"@/contacthelp/Allowances.js\";\nimport getethProvider from '@/contacthelp/getethProvider.js';\nimport _ from 'underscore';\n\nimport {\n  useTokenContractMulticall,\n  useIUniswapV2PairABIContractMulticall\n} from \"../contacthelp/useContractMulticall.js\";\nimport { Contract, Provider } from '@webfans/ethers-multicall';\nimport { ethers } from 'ethers';\nimport { INITIAL_ALLOWED_SLIPPAGE, ROUTER_ADDRESS } from '@/constants/index.js';\n\nimport { calculateSlippageAmount, getRouterContract, calculateGasMargin } from '@/contacthelp/utils.js';\n\nimport Web3 from 'web3';\n\nimport { getTime } from \"@/contacthelp/ethcom.js\";\n\n\nimport { splitSignature } from \"@ethersproject/bytes\";\nimport { getGasPrice } from '@/contacthelp/ethusdt.js';\n// import bignumber from  \"bignumber.js\"\nconst BigNumber = require(\"bignumber.js\");\n\nimport { pairPrice } from '@/constants/apiconfig.js';\n\nimport { swapExactTokensForTokensformat } from './history.js';\nimport getChainCoinInfo from '@/constants/networkCoinconfig.js';\n\n\n\nfunction Calculatepercentage(balance, totalSupply) {\n  const balance_ = new BigNumber(balance);\n  const totalSupply_ = new BigNumber(totalSupply);\n  return balance_.div(totalSupply_);\n\n\n}\nexport function  getTokenList(chainID){\n   return   _.where(token.tokens, { chainId: chainID });\n}\n\nexport async function readpairpool(chainID, library) {\n  const list = _.where(pairlist, { chainId: chainID });\n  const tokenList = _.where(token.tokens, { chainId: chainID });\n  const callList = [];\n\n  // list.forEach(async element => {\n\n  //   const coinA = _.find(tokenList, { symbol: element.pair[0] });\n  //   const coinB = _.find(tokenList, { symbol: element.pair[1] });\n  //   const TokenA = new Token(coinA.chainId, coinA.address, coinA.decimals, coinA.symbol);\n  //   const TokenB = new Token(coinB.chainId, coinB.address, coinB.decimals, coinB.symbol);\n  //   try {\n  //     const pairCall = Fetcher.fetchPairData(TokenA, TokenB, getethProvider(TokenB));\n  //     callList.push(pairCall);\n  //   } catch (error) {\n  //     console.log(error);\n  //     console.log(coinA.symbol,coinB.symbol);\n\n  //   }\n\n\n  // });\n  let PairList;\n//  try {\n   PairList = await pairList(chainID,library);\n//  } catch (error) {\n//    console.log('error',error,callList);\n//    PairList=[];\n//  }\n\n\n  // console.log(PairList);\n  const dataList = [];\n  /*\n  this.$data.price = price.toSignificant(6);\n  this.$data.invertprice = price.invert().toSignificant(6);\n  */\n  const PricePromiseList = [];\n  PairList.forEach(async element => {\n    const route = new Route([element], element.tokenAmounts[0].token);\n\n    const tokenA = element.tokenAmounts[0].token;\n    const tokenB = element.tokenAmounts[1].token;\n    const pairaddress = element.liquidityToken.address;\n\n    const  target = _.find(list,(one)=>{\n      if(one.pair.indexOf(tokenB.symbol)!=-1&&one.pair.indexOf(tokenA.symbol)!=-1){\n        return  one;\n      }\n    });\n\n    let price  ;\n    if(target.pair[1]==tokenA.symbol){\n       price = route.pairs[0].priceOf(tokenB);\n\n    }else{\n      price = route.pairs[0].priceOf(tokenA);\n\n    }\n\n\n\n    // PricePromiseList.push(getpairPrice(pairaddress, chainID, target.pair[0], target.pair[1]));\n\n    dataList.push({\n      Pair: element,\n      price: price.toSignificant(6),\n      pairName: `${target.pair[0]}/${target.pair[1]}`,\n      listSymbol: target.isfirst=='true'?target.pair[0]:target.pair[1],\n      pairSymbols: [element.tokenAmounts[0].token.symbol, element.tokenAmounts[1].token.symbol],\n      configSymbols: [target.pair[0], target.pair[1]],\n      isHide:target.isHide\n\n    });\n\n  });\n\n  // const PriceList = await Promise.all(PricePromiseList);\n  // console.log('PriceList', PriceList);\n  // dataList.forEach((item) => {\n\n  //   const prise24 = _.find(PriceList, (one) => {\n  //     if (one&&one[item.pairName]) {\n  //       return one;\n\n  //     }\n\n  //   });\n  //   if (prise24) {\n  //     item.prise24 = prise24[item.pairName];\n  //     if (item.price - item.prise24 > 0) {\n  //       item.change = '+';\n  //     } else {\n  //       item.change = '-';\n  //     }\n  //     item.prisechange = Math.abs((item.price - item.prise24) / item.prise24);\n\n\n\n  //   } else {\n  //     item.prisechange = '';\n  //   }\n\n\n\n  // });\n\n  // console.log(dataList);\n  return dataList;\n\n  //     const ethcallProvider = new Provider(library,chainID);\n  //   await ethcallProvider.init(); // Only required when `chainId` is not provided in the `Provider` constructor\n  //   const result = await ethcallProvider.all(callList);\n  //   console.log(result);\n}\n\nexport async function readpairpoolPrice(chainID, library,pairdataList){\n  const list = _.where(pairlist, { chainId: chainID });\n  const tokenList = _.where(token.tokens, { chainId: chainID });\n  const callList = [];\n  const PricePromiseList=[];\n\n  list.forEach((target)=>{\n\n    const coinA = _.find(tokenList, { symbol: target.pair[0] });\n    const coinB = _.find(tokenList, { symbol: target.pair[1] });\n    const TokenA = new Token(coinA.chainId, coinA.address, coinA.decimals, coinA.symbol);\n    const TokenB = new Token(coinB.chainId, coinB.address, coinB.decimals, coinB.symbol);\n    const pairaddress = Pair.getAddress(TokenA, TokenB);\n\n    PricePromiseList.push(getpairPrice(pairaddress, chainID, target.pair[0], target.pair[1]));\n\n  });\n  const PriceList = await Promise.all(PricePromiseList);\n\n\n   pairdataList.forEach((item) => {\n\n    const prise24 = _.find(PriceList, (one) => {\n      if (one&&one[item.pairName]) {\n        return one;\n\n      }\n\n    });\n    if (prise24) {\n      item.prise24 = prise24[item.pairName];\n      if (item.price - item.prise24 > 0) {\n        item.change = '+';\n      } else {\n        item.change = '-';\n      }\n      item.prisechange = Math.abs((item.price - item.prise24) / item.prise24);\n\n\n\n    } else {\n      item.prisechange = '';\n    }\n\n\n\n  });\n\n  return pairdataList;\n\n\n\n}\n\nexport async function readpairLiquidity(chainID, library, account) {\n  const list = await readpairpool(chainID, library);\n  const callList = [];\n  list.forEach((element) => {\n\n    const TokenContract = useTokenContractMulticall(element.Pair.liquidityToken);\n\n\n    callList.push(TokenContract.totalSupply());\n    if (account != \"\") {\n      callList.push(TokenContract.balanceOf(account));\n    }\n\n\n  });\n\n  const ethcallProvider = new Provider(library, chainID);\n  await ethcallProvider.init(); // Only required when `chainId` is not provided in the `Provider` constructor\n  const listresult = await ethcallProvider.all(callList);\n\n  console.log(listresult);\n\n\n  list.forEach((item, index) => {\n\n    let balance = '0', totalSupply = '';\n    if (account != '') {\n      totalSupply = listresult[index * 2];\n      balance = listresult[index * 2 + 1];\n    } else {\n      totalSupply = listresult[index];\n    }\n\n\n    const totalSupplyTokenAmount = new TokenAmount(item.Pair.liquidityToken, totalSupply.toString());\n\n    const balanceTokenAmount = new TokenAmount(item.Pair.liquidityToken, balance.toString());\n\n    item.totalSupply = Web3.utils.fromWei(totalSupply.toString());\n    item.balance = Web3.utils.fromWei(balance.toString());\n    console.log('-------');\n\n    item.aToketotalSupply = item.Pair.getLiquidityValue(item.Pair.tokenAmounts[0].token, totalSupplyTokenAmount, totalSupplyTokenAmount, false);\n    item.bToketotalSupply = item.Pair.getLiquidityValue(item.Pair.tokenAmounts[1].token, totalSupplyTokenAmount, totalSupplyTokenAmount, false);\n\n    item.aTokenbalance = item.Pair.getLiquidityValue(item.Pair.tokenAmounts[0].token, totalSupplyTokenAmount, balanceTokenAmount, false).toSignificant(3);\n    item.bTokenbalance = item.Pair.getLiquidityValue(item.Pair.tokenAmounts[1].token, totalSupplyTokenAmount, balanceTokenAmount, false).toSignificant(3);\n\n\n\n  });\n\n  return list;\n\n  // 读取总量\n  //读物我的余额\n  //根据我的余额和总量关系，换算两个币中分别是多少\n}\n\nexport async function readpariInfo(chainID, library, tokensymbolA, tokensymbolB) {\n\n  const tokenList = _.where(token.tokens, { chainId: chainID });\n\n  const coinA = _.find(tokenList, { symbol: tokensymbolA });\n  const coinB = _.find(tokenList, { symbol: tokensymbolB });\n\n  const TokenA = new Token(coinA.chainId, coinA.address, coinA.decimals, coinA.symbol);\n  const TokenB = new Token(coinB.chainId, coinB.address, coinB.decimals, coinB.symbol);\n\n  const pairInfo = await Fetcher.fetchPairData(TokenA, TokenB, getethProvider(TokenB));\n\n  return pairInfo;\n\n\n\n}\n\nexport async function calculationLiquidity(library, chainID, coinATokenAmount, coinBTokenAmount, istargetBToken, account) {\n  console.log('calculationLiquidity');\n\n  const pair = await Fetcher.fetchPairData(\n    coinATokenAmount.token,\n    coinBTokenAmount.token,\n    getethProvider(coinBTokenAmount.token)\n  );\n  // console.log(pair);\n  let route;\n\n  route = new Route([pair], coinATokenAmount.token);\n\n  const price = route.pairs[0].priceOf(coinATokenAmount.token);\n  const invertprice = price.invert();\n\n  let outputNum;\n\n  if (istargetBToken) {\n    outputNum = route.pairs[0].priceOf(coinATokenAmount.token).quote(coinATokenAmount);\n  } else {\n    outputNum = route.pairs[0].priceOf(coinBTokenAmount.token).quote(coinBTokenAmount);\n\n  }\n\n  const TokenContract = useTokenContractMulticall(pair.liquidityToken);\n  const callList = [];\n\n  callList.push(TokenContract.totalSupply());\n  callList.push(TokenContract.balanceOf(account));\n\n  const ethcallProvider = new Provider(library, chainID);\n  await ethcallProvider.init(); // Only required when `chainId` is not provided in the `Provider` constructor\n  const listresult = await ethcallProvider.all(callList);\n\n  const [pooltotalSupply, mypoolBlance] = listresult;\n\n  const pooltotalSupplyTokenAmount = new TokenAmount(\n    pair.liquidityToken,\n    pooltotalSupply.toString());\n\n  let liquidityMinted;\n\n  if (istargetBToken) {\n    liquidityMinted = pair.getLiquidityMinted(pooltotalSupplyTokenAmount, coinATokenAmount, outputNum);\n  } else {\n    liquidityMinted = pair.getLiquidityMinted(pooltotalSupplyTokenAmount, outputNum, coinBTokenAmount);\n  }\n\n  let poolPercentData = liquidityMinted.divide(pooltotalSupplyTokenAmount.add(liquidityMinted));\n  poolPercentData = poolPercentData.toSignificant(4);\n\n  // if (poolPercentData.multiply(10000).lessThan(1)) {\n  //   poolPercentData = '<0.01';\n  // } else {\n  //   poolPercentData = poolPercentData.multiply(100).toSignificant(4);\n  // }\n\n  return {\n    istargetBToken,\n    outputNum,\n    poolPercentData,\n    price,\n    invertprice,\n    liquidityMinted\n\n  };\n\n\n  //let poolBlance = await this.getTokenbalance(pair.liquidityToken, window.ethersprovider, this.ethAddress);\n  //let poolTotal = await this.getTokenTotalSupply(window.ethersprovider, this.ethAddress, pair.liquidityToken);\n\n\n\n}\n\nexport async function buildAddliquidityParam(coinATokenAmount, coinBTokenAmount, account,ChainId) {\n\n  const allowedSlippage = INITIAL_ALLOWED_SLIPPAGE;\n\n  const amountsMin = {\n    CURRENCY_A: calculateSlippageAmount(coinATokenAmount, allowedSlippage)[0],\n    CURRENCY_B: calculateSlippageAmount(coinBTokenAmount, allowedSlippage)[0],\n  };\n  const blockTime = await getTime();\n  // 20 minutes, denominated in seconds\n  const DEFAULT_DEADLINE_FROM_NOW = 60 * 20;\n\n  const deadline = blockTime + DEFAULT_DEADLINE_FROM_NOW;\n\n  const coinInfo = getChainCoinInfo(ChainId);\n\n  let args ;\n\n  if(coinATokenAmount.currency.symbol ==coinInfo.coinName||\n    coinBTokenAmount.currency.symbol ==coinInfo.coinName){\n      const isBisEth = coinBTokenAmount.currency.symbol ==coinInfo.coinName;\n      args = [\n        isBisEth?coinATokenAmount.currency.address:coinBTokenAmount.currency.address,\n        isBisEth?coinATokenAmount.raw.toString():coinBTokenAmount.raw.toString(),\n        amountsMin['CURRENCY_A'].toString(),\n        amountsMin['CURRENCY_B'].toString(),\n        account,\n        Web3.utils.asciiToHex(deadline + ''),\n      ];\n\n  }else{\n    args = [\n      coinATokenAmount.currency.address,\n      coinBTokenAmount.currency.address,\n      coinATokenAmount.raw.toString(),\n      coinBTokenAmount.raw.toString(),\n      amountsMin['CURRENCY_A'].toString(),\n      amountsMin['CURRENCY_B'].toString(),\n      account,\n      Web3.utils.asciiToHex(deadline + ''),\n    ];\n\n  }\n\n  return args;\n\n}\n\nexport async function checkoutTokenAllowance(tokenA, tokenB, library, chainID, account) {\n\n  // ROUTER_ADDRESS\n\n  const TokenAContract = useTokenContractMulticall(tokenA);\n  const TokenBContract = useTokenContractMulticall(tokenB);\n\n  const callList = [TokenAContract.allowance(account, ROUTER_ADDRESS),\n  TokenBContract.allowance(account, ROUTER_ADDRESS)];\n\n  const ethcallProvider = new Provider(library, chainID);\n  await ethcallProvider.init(); // Only required when `chainId` is not provided in the `Provider` constructor\n  const listresult = await ethcallProvider.all(callList);\n\n  const [tokenAallowance, tokenBallowance] = listresult;\n\n  return {\n    tokenAallowance,\n    tokenBallowance\n  };\n\n\n\n}\n\n\nexport async function readpariInfoNuminfo(chainID, library, account, tokensymbolA, tokensymbolB) {\n  console.log('readpariInfoNuminfo');\n  const pairInfo = await readpariInfo(chainID, library, tokensymbolA, tokensymbolB);\n  const callList = [];\n\n  const TokenContract = useTokenContractMulticall(pairInfo.liquidityToken);\n\n\n  callList.push(TokenContract.totalSupply());\n  callList.push(TokenContract.balanceOf(account));\n\n  const ethcallProvider = new Provider(library, chainID);\n  await ethcallProvider.init(); // Only required when `chainId` is not provided in the `Provider` constructor\n  const listresult = await ethcallProvider.all(callList);\n  const totalSupply = listresult[0];\n  const balance = listresult[1];\n\n\n  const totalSupplyTokenAmount = new TokenAmount(pairInfo.liquidityToken, totalSupply.toString());\n  const balanceTokenAmount = new TokenAmount(pairInfo.liquidityToken, balance.toString());\n\n  const aToketotalSupply = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[0].token, totalSupplyTokenAmount, totalSupplyTokenAmount, false);\n  const bToketotalSupply = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[1].token, totalSupplyTokenAmount, totalSupplyTokenAmount, false);\n\n  const aTokenbalance = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[0].token, totalSupplyTokenAmount, balanceTokenAmount, false);\n  const bTokenbalance = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[1].token, totalSupplyTokenAmount, balanceTokenAmount, false);\n\n  const route = new Route([pairInfo], pairInfo.tokenAmounts[0].token);\n  const price = route.pairs[0].priceOf(pairInfo.tokenAmounts[0].token);\n\n  let poolPercentData = Calculatepercentage(balance.toString(), totalSupply.toString());\n  poolPercentData = poolPercentData.toString();\n\n  //  if (poolPercentData.times(10000).isLessThan(1)) {\n  //   poolPercentData = '<0.01';\n  // } else {\n  //   poolPercentData = poolPercentData.times(100).toString();\n  // }\n\n  return {\n    pairInfo,\n    aToketotalSupply,\n    bToketotalSupply,\n    aTokenbalance,\n    bTokenbalance,\n    totalSupply,\n    balance,\n    price,\n    priceinvert: price.invert(),\n    poolPercentData\n  };\n\n}\n\n\nexport async function checkApprove(chainID, library, account, coinATokenAmount, coinBTokenAmount) {\n\n  //coinATokenAmount.token\n  const TokenAContract = useTokenContractMulticall(coinATokenAmount.token);\n  const TokenBContract = useTokenContractMulticall(coinBTokenAmount.token);\n\n  const spender = ROUTER_ADDRESS;\n  const callList = [];\n\n  callList.push(TokenAContract.allowance(account, spender));\n  callList.push(TokenBContract.allowance(account, spender));\n\n  const ethcallProvider = new Provider(library, chainID);\n  await ethcallProvider.init(); // Only required when `chainId` is not provided in the `Provider` constructor\n  const listresult = await ethcallProvider.all(callList);\n  const [Aallowance, Ballowance] = listresult;\n\n  console.log(Aallowance, Ballowance);\n  let tokenAnotNeed = false, tokenBnotNeed = false;\n  const aUserin = new BigNumber(coinATokenAmount.raw.toString());\n  const bUserin = new BigNumber(coinBTokenAmount.raw.toString());\n\n  if (aUserin.lt(Aallowance.toString()) || aUserin.eq(Aallowance.toString())) {\n    tokenAnotNeed = true;\n  }\n\n  if (bUserin.lt(Ballowance.toString()) || bUserin.eq(Ballowance.toString())) {\n    tokenBnotNeed = true;\n  }\n\n  // const tokenAnotNeed = coinATokenAmount.isLessThanOrEqualTo(Aallowance.toString());\n\n  // const tokenBnotNeed = coinBTokenAmount.isLessThanOrEqualTo(Ballowance.toString());\n\n  return {\n    tokenAnotNeed,\n    tokenBnotNeed\n  };\n\n\n}\n\nexport async function addliquidityGas(chainID, library, account, parameters,ethamount) {\n  const contract = getRouterContract(chainID, library, account);\n\n  let  estimatedGasLimit;\n\n  if(parameters.length== 6){\n    estimatedGasLimit = await contract.estimateGas.addLiquidityETH(...parameters, {value:ethamount});\n  }else{\n    estimatedGasLimit = await contract.estimateGas.addLiquidity(...parameters, {});\n  }\n\n  const gasPrice = await getGasPrice(library);\n\n  const useWEI = estimatedGasLimit.mul(gasPrice);\n  const fee = Web3.utils.fromWei(useWEI.toString());\n\n  return fee;\n}\n\nexport async function sendaddliquidity(chainID, library, account, parameters,ethamount) {\n\n  const contract = getRouterContract(chainID, library, account);\n\n  let  estimatedGasLimit;\n  if(parameters.length== 6){\n    estimatedGasLimit = await contract.estimateGas.addLiquidityETH(...parameters, {value:ethamount});\n }else{\n   estimatedGasLimit = await contract.estimateGas.addLiquidity(...parameters, {});\n }\n\n let result ;\n if(parameters.length== 6){\n    result = await contract.addLiquidityETH(...parameters, {\n      ...{\n        value:ethamount\n      },\n     gasLimit: calculateGasMargin(estimatedGasLimit),\n   });\n\n }else{\n     result = await contract.addLiquidity(...parameters, {\n     ...{},\n     gasLimit: calculateGasMargin(estimatedGasLimit),\n   });\n\n }\n  return result;\n\n}\n\nexport async function getpairPrice(pairaddress, chainID, tokenA, tokenB) {\n  console.log('getpairPrice');\n  const data = await pairPrice(pairaddress);\n  if (data == '') {\n    return null;\n  }\n  const PriceInfo = swapExactTokensForTokensformat(data.Data.txs, chainID, tokenA, tokenB);\n  // inamount: \"1000000000000000000\"\n  // outamount: \"187379656538552111\"\n  // tokenA: \"USDT\"\n  // tokenB: \"scUSD\"\n  if (!PriceInfo) {\n    return null;\n  }\n\n\n  const innum = new BigNumber(PriceInfo.inamount);\n  const outnum = new BigNumber(PriceInfo.outamount);\n\n  const infoData = {\n    [PriceInfo.tokenA+\"/\"+PriceInfo.tokenB]:outnum.div(innum).toFixed(8),\n    [PriceInfo.tokenB+\"/\"+PriceInfo.tokenA]:innum.div(outnum).toFixed(8),\n  };\n  const obj = {};\n  obj[tokenA + '/' + tokenB] = infoData[tokenA + '/' + tokenB];\n  return obj;\n\n\n}\n\nexport async function pairList(chainID,library){\n  const list = _.where(pairlist, { chainId: chainID });\n  const tokenList = _.where(token.tokens, { chainId: chainID });\n  const callList = [];\n\n  console.log('pairList');\n\n  list.forEach(async element => {\n\n    const coinA = _.find(tokenList, { symbol: element.pair[0] });\n    const coinB = _.find(tokenList, { symbol: element.pair[1] });\n    const TokenA = new Token(coinA.chainId, coinA.address, coinA.decimals, coinA.symbol);\n    const TokenB = new Token(coinB.chainId, coinB.address, coinB.decimals, coinB.symbol);\n    const pairAddress = Pair.getAddress(TokenA, TokenB);\n    // console.log(TokenA, TokenB,pairAddress);\n\n    const UniswapV2Pair = useIUniswapV2PairABIContractMulticall({address:pairAddress});\n\n    callList.push(UniswapV2Pair.token0());\n    callList.push(UniswapV2Pair.token1());\n    callList.push(UniswapV2Pair.getReserves());\n\n\n  });\n\n  const ethcallProvider = new Provider(library,chainID);\n    await ethcallProvider.init(); // Only required when `chainId` is not provided in the `Provider` constructor\n    const result = await ethcallProvider.all(callList);\n    // console.log(result);\n    const pairList = [];\n    for (let index = 0; index < result.length; index+=3) {\n      const tokrnAddressA = result[index];\n      const tokrnAddressB = result[index+1];\n      const [reserve0, reserve1] = result[index+2];\n\n      const coinA = _.find(tokenList, (item)=>{\n          return item.address.toLowerCase() == tokrnAddressA.toLowerCase();\n      });\n      const coinB = _.find(tokenList, (item)=>{\n          return item.address.toLowerCase() == tokrnAddressB.toLowerCase();\n        });\n\n      const TokenA = new Token(coinA.chainId, coinA.address, coinA.decimals, coinA.symbol);\n      const TokenB = new Token(coinB.chainId, coinB.address, coinB.decimals, coinB.symbol);\n\n      const tokens = [TokenA,TokenB];\n      const [token0, token1] = tokens[0].sortsBefore(tokens[1]) ? tokens : [tokens[1], tokens[0]];\n\n      const pair = new Pair(new TokenAmount(token0, reserve0), new TokenAmount(token1, reserve1));\n      // console.log(pair);\n      pairList.push(pair);\n\n    }\n\n    return pairList;\n\n}\n\nexport async function pairListEarn(chainID, library) {\n  console.log('pairListEarn');\n  // const pairInfo = await readpariInfo(chainID, library, tokensymbolA, tokensymbolB);\n  const pairListInfo = await pairList(chainID,library);\n  const callList = [];\n\n  pairListInfo.forEach((pairInfo)=>{\n    const TokenContract = useTokenContractMulticall(pairInfo.liquidityToken);\n      callList.push(TokenContract.totalSupply());\n  });\n\n\n\n  //  callList.push(TokenContract.balanceOf(account));\n\n  const ethcallProvider = new Provider(library, chainID);\n  await ethcallProvider.init(); // Only required when `chainId` is not provided in the `Provider` constructor\n  const listresult = await ethcallProvider.all(callList);\n  const resultList =[];\n\n  pairListInfo.forEach((pairInfo,index)=>{\n    const totalSupply = listresult[index];\n\n    const totalSupplyTokenAmount = new TokenAmount(pairInfo.liquidityToken, totalSupply.toString());\n\n\n\n    //  const aToketotalSupply = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[0].token, totalSupplyTokenAmount, totalSupplyTokenAmount, false);\n    //  const bToketotalSupply = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[1].token, totalSupplyTokenAmount, totalSupplyTokenAmount, false);\n\n    const aTokenbalance = (pledgebalance)=>{\n      const balanceTokenAmount = new TokenAmount(pairInfo.liquidityToken, pledgebalance.toString());\n     return pairInfo.getLiquidityValue(pairInfo.tokenAmounts[0].token, totalSupplyTokenAmount, balanceTokenAmount, false);\n\n    };\n    const bTokenbalance =(pledgebalance)=>{\n      const balanceTokenAmount = new TokenAmount(pairInfo.liquidityToken, pledgebalance.toString());\n     return pairInfo.getLiquidityValue(pairInfo.tokenAmounts[1].token, totalSupplyTokenAmount, balanceTokenAmount, false);\n    };\n\n    const route = new Route([pairInfo], pairInfo.tokenAmounts[0].token);\n    //tokensymbolA, tokensymbolB\n\n    const price=(tokensymbolA,tokensymbolB)=>{\n      let price;\n      const pairprice={};\n      if(tokensymbolB ==  pairInfo.tokenAmounts[0].token.symbol){\n        price = route.pairs[0].priceOf(pairInfo.tokenAmounts[1].token);\n        pairprice[tokensymbolA+\"/\"+tokensymbolB] = route.pairs[0].priceOf(pairInfo.tokenAmounts[1].token).toSignificant(6);\n        pairprice[tokensymbolB+\"/\"+tokensymbolA] = route.pairs[0].priceOf(pairInfo.tokenAmounts[0].token).toSignificant(6);\n      }else{\n        price = route.pairs[0].priceOf(pairInfo.tokenAmounts[0].token);\n        pairprice[tokensymbolB+\"/\"+tokensymbolA] = route.pairs[0].priceOf(pairInfo.tokenAmounts[1].token).toSignificant(6);\n        pairprice[tokensymbolA+\"/\"+tokensymbolB] = route.pairs[0].priceOf(pairInfo.tokenAmounts[0].token).toSignificant(6);\n      }\n      return {\n        price,\n        pairprice,\n        priceinvert: price.invert(),\n      };\n\n    };\n\n\n\n    resultList.push({\n      pairInfo,\n      // aToketotalSupply,\n      // bToketotalSupply,\n      aTokenbalance,\n      bTokenbalance,\n      totalSupply,\n      price,\n      // priceinvert: price.invert(),\n      // pairprice\n\n    });\n\n  });\n\n\n  //  const  balance = listresult[1];\n\n\n  // console.log(pairprice);\n\n\n\n  return resultList;\n\n}\n\n\n\n/*\nroute = new Route([pair], coinATokenAmount.token);\n\n            var price = route.pairs[0].priceOf(coinATokenAmount.token);\n\nthis.$data.price = price.toSignificant(6);\n            this.$data.invertprice = price.invert().toSignificant(6);\n*/\n\n\n/*\nasync function getPairs(pairList) {\n    var userpairList = [] ;\n    for (let index = 0; index < pairList.length; index++) {\n      const element = pairList[index];\n      const TokenA = new Token(element.coinA.chainId,element.coinA.address,element.coinA.decimals,element.coinA.symbol);\n      const TokenB = new Token(element.coinB.chainId,element.coinB.address,element.coinB.decimals,element.coinB.symbol);\n      try {\n        const pair = await Fetcher.fetchPairData(TokenA, TokenB,getethProvider(TokenB));\n        console.log(pair)\n        userpairList.push(pair)\n\n      } catch (error) {\n          console.log('not find the pair',TokenA,TokenB)\n\n      }\n\n    }\n    return  userpairList;\n\n  }\n\nasync function checkPairsUserbalance(pairList,library, account){\n    var list = [];\n    for (let index = 0; index < pairList.length; index++) {\n        const element = pairList[index];\n        var data = await getbalance(element.liquidityToken,library, account);\n        pairList[index].userbalance = data;\n        // if(data.greaterThan(0)){\n            list.push(pairList[index])\n        // }\n\n\n    }\n     return list ;\n\n}\n\n\n*/\n\nexport async function readpariInfoNuminfoEarn(chainID, library, tokensymbolA, tokensymbolB, pledgebalance) {\n  // console.log('readpariInfoNuminfo');\n  const pairInfo = await readpariInfo(chainID, library, tokensymbolA, tokensymbolB);\n  const callList = [];\n\n  const TokenContract = useTokenContractMulticall(pairInfo.liquidityToken);\n\n\n  callList.push(TokenContract.totalSupply());\n  //  callList.push(TokenContract.balanceOf(account));\n\n  const ethcallProvider = new Provider(library, chainID);\n  await ethcallProvider.init(); // Only required when `chainId` is not provided in the `Provider` constructor\n  const listresult = await ethcallProvider.all(callList);\n  const totalSupply = listresult[0];\n  //  const  balance = listresult[1];\n\n\n  const totalSupplyTokenAmount = new TokenAmount(pairInfo.liquidityToken, totalSupply.toString());\n  const balanceTokenAmount = new TokenAmount(pairInfo.liquidityToken, pledgebalance.toString());\n\n  //  const aToketotalSupply = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[0].token, totalSupplyTokenAmount, totalSupplyTokenAmount, false);\n  //  const bToketotalSupply = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[1].token, totalSupplyTokenAmount, totalSupplyTokenAmount, false);\n\n  const aTokenbalance = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[0].token, totalSupplyTokenAmount, balanceTokenAmount, false);\n  const bTokenbalance = pairInfo.getLiquidityValue(pairInfo.tokenAmounts[1].token, totalSupplyTokenAmount, balanceTokenAmount, false);\n\n  const route = new Route([pairInfo], pairInfo.tokenAmounts[0].token);\n  //tokensymbolA, tokensymbolB\n  const pairprice={};\n  let price;\n  if(tokensymbolB ==  pairInfo.tokenAmounts[0].token.symbol){\n    price = route.pairs[0].priceOf(pairInfo.tokenAmounts[1].token);\n    pairprice[tokensymbolA+\"/\"+tokensymbolB] = route.pairs[0].priceOf(pairInfo.tokenAmounts[1].token).toSignificant(6);\n    pairprice[tokensymbolB+\"/\"+tokensymbolA] = route.pairs[0].priceOf(pairInfo.tokenAmounts[0].token).toSignificant(6);\n  }else{\n    price = route.pairs[0].priceOf(pairInfo.tokenAmounts[0].token);\n    pairprice[tokensymbolB+\"/\"+tokensymbolA] = route.pairs[0].priceOf(pairInfo.tokenAmounts[1].token).toSignificant(6);\n    pairprice[tokensymbolA+\"/\"+tokensymbolB] = route.pairs[0].priceOf(pairInfo.tokenAmounts[0].token).toSignificant(6);\n  }\n  // console.log(pairprice);\n\n\n\n  return {\n    pairInfo,\n    // aToketotalSupply,\n    // bToketotalSupply,\n    aTokenbalance,\n    bTokenbalance,\n    totalSupply,\n    price,\n    priceinvert: price.invert(),\n    pairprice\n\n  };\n\n}\n\nexport function getLPName(A,B,chainID){\n  const list = _.where(pairlist, { chainId: chainID });\n  const  target = _.find(list,(one)=>{\n    if(one.pair.indexOf(B)!=-1&&one.pair.indexOf(A)!=-1){\n      return  one;\n    }\n  });\n  if(target){\n    return {\n      pairName:target.pair[0]+\"/\"+target.pair[1],\n      listSymbol: target.pair[0],\n    };\n\n  }else{\n    return {\n      pairName:'--',\n      listSymbol: '--',\n    };\n\n  }\n\n\n}"],"sourceRoot":""}